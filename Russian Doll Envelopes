
Program : https://leetcode.com/problems/russian-doll-envelopes/

Companies : #amazon #google #microsoft
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Problem :

You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.

One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.

Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).

Note: You cannot rotate an envelope.

 

Example 1:

Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
Example 2:

Input: envelopes = [[1,1],[1,1],[1,1]]
Output: 1
 

Constraints:

1 <= envelopes.length <= 105
envelopes[i].length == 2
1 <= wi, hi <= 105
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Explanation :

it is same as https://leetcode.com/submissions/detail/1878857943/ (Find the Longest Valid Obstacle Course at Each Position) where we first sort the widths, there itself we stop considering
the widths.
so at the end of the iteration if we got (4,5),(4,6),(4,7) => in this case the answer will be (4,7) = 1.
but if we go to (Find the Longest Valid Obstacle Course at Each Position) program, if [5,6,7] gives answer as 3. because there it is increasing here it is placing one insider another.
so instead if we get (4,5),(4,6),(4,7) like same width, different heights, we sort them in reverse height order.
so it become (4,7),(4,6),(4,5) => (7,6,5) as per (Find the Longest Valid Obstacle Course at Each Position) program, it will become 7. 1 as the answer.

we store the increasing the result envelopes's height as result[], at each index of the result we are storing the no. of increasing or equal elements before that including itself.
so for that we maintains an array, at each index we either inserts it, or updates old value. i.e,
[3,1,5,6,4,2]
for 0th index. => [3]
for 1th index. => [1] (as the elements should be increasing any sequence that forms with 3 can be formed with 1)
for 2nd index. => [1,5] 
for 3rd index. => [1,5,6]
for 4th index. => [1,4,6] (so in this way, any sequence that can be formed with 5 can be formed with 4 as well)
for 5th index. => [1,2,6]

in this way for each index we store the result as the arr size => [1,1,2,3,3,3].

so how can we find the index so that we can replace the elements ?

we have to get the lower bounds.

Here comes the trickest part, there are many binary search approaches, one solves, lowerbound, one solves upperbound, one solves exact find.
Here 1st what we need ?
we have to get the first maximum element index for a value, i.e, first index of an element which is greater than or equals i.e, lowerbound.

so if we found same element anywhere ? we have to look if it is first element or any same values exists before, i.e, end = mid;
if we find greater element anywhere ? if any less value doesn't exists, the greater element will be the answer, or else less value index. i.e, end = mid;
in both the cases we store the mid because it is possible solution.

if we find lesser than, that is not at all answer, so we just skip it. so, srt=mid+1.

in this way our logic will be.

            if(arr[mid] > obstacle)
                end = mid;
            else 
                srt=mid+1;

in this way for each index, we loop through the elements are find the result.

and why srt<end not srt<=end, because when we want to find insertion points or upper or lower bounds, we will use <, when we want to find exact index we use <= and return -1 on base
condition.

for while <=, it will end at left>right, which not a valid condition at all, at such case we maintain result and update it every required moment, and return it.

Every <= condition can be written in < form. Better to go with one approach everytime.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution :

class Solution {
    int findIndex(int[] arr,int size,int envelope){
        int srt = 0, end = size;
        while(srt<end){
            int mid = (srt+end)>>1;
            if(arr[mid]>=envelope) end = mid;
            else srt = mid+1;
        }
        return srt;
    }
    public int maxEnvelopes(int[][] envelopes) {
        int len = envelopes.length;

        int count = 0;
        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);
        int[] result = new int[len];

        int max = 0;
        int size = 0;

        for(int i=0;i<len;i++){
            int ind = findIndex(result,size,envelopes[i][1]);
            if(ind==size){
                result[size++]=envelopes[i][1];
            }
            else{
                result[ind] = Math.min(result[ind],envelopes[i][1]);
            }
            max = Math.max(max,size);
        }


        return max;
    }
}

